# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_battery.ipynb.

# %% auto 0
__all__ = ['Cell', 'Battery', 'cells_for_voltage', 'miles_per_cell']

# %% ../nbs/03_battery.ipynb 3
from .motor import evaluate
from .utilities import *
import numpy as np
from fastcore.utils import *

# %% ../nbs/03_battery.ipynb 5
class Cell():
  """ Defines a single cell. """
  def __init__(self,
               name='Generic Cell',
               voltage=3.2, # V DC, nominal
               capacity=140, # Ah
               dimensions = {'length':None, 'width':None, 'height':None}, # inches
               mass = None, # lbs
               cost = None, # USD
               ):
    self.voltage = voltage
    self.capacity = capacity
    self.kWh = capacity*voltage/1000
    self.energy = None
    self.mass = mass
    self.cost = cost
    self.name = name
    self.dimensions = dimensions
    if self.dimensions['length'] is not None and self.dimensions['width'] is not None and self.dimensions['height'] is not None:
      self.volume = self.dimensions['length']*self.dimensions['width']*self.dimensions['height']
    else:
      self.volume = None
    self.power = None
    self.current = None
    self.resistance = None
    self.efficiency = None
    
    def __repr__(self):
      return f'{self.name} ({round(self.voltage,2)}V, {round(self.capacity,2)}Ah, {round(self.mass,2)} lbs'

class Battery():
  """ Defines a battery as a collection of cells. Cells are assumed to 
  be connected in series."""
  def __init__(self, cell=Cell(),
               motor_voltage=144, # V DC, nominal,
               n_cells=None, # number of cells in series
               ):
    self.cell = cell
    self.name = cell.name + ' Battery'
    if not n_cells:
      self.n_cells = cells_for_voltage(motor_voltage=motor_voltage, cell_voltage=cell.voltage)
    else:
      self.n_cells = n_cells
    self.voltage = self.n_cells*cell.voltage
    self.kWh = self.n_cells*cell.kWh
    self.energy = None
    if self.cell.mass is not None:
      self.mass = self.n_cells*cell.mass
    else:
      self.mass = None
    if cell.cost is not None:
      self.cost = self.n_cells*cell.cost
    else:
      self.cost = None
    if self.cell.volume is not None:
      self.volume = self.n_cells*self.cell.volume
    else:
      self.volume = None
    self.power = None
    self.current = None
    self.resistance = None
    self.efficiency = None
    
  def __repr__(self):
    return f'{self.name} ({round(self.voltage,2)}V, {round(self.kWh,2)}kWh, {round(self.mass,2)} lbs)'

def cells_for_voltage(motor_voltage=None, # motor V DC, nominal
                  cell_voltage=3.2, # individual cell V DC, nominal
                )->int: # number of cells required
    """Returns the number of cells required to achieve the desired motor voltage.
    Rounds up to the nearest integer.
    """
    return int(np.floor(motor_voltage/cell_voltage))


# %% ../nbs/03_battery.ipynb 10
def miles_per_cell(cell=None, # cell object
                miles_per_kwh=5, # km per kWh
                )->float: # km per cell
    """Returns the number of km per cell.
    """
    if cell:
        return cell.kWh*miles_per_kwh
    else:
        raise ValueError("No cell object provided.")

@patch
def range(self:Battery,
        miles_per_kwh=5, # miles per kWh
        )->float: # miles range
    """Returns the range estimate for the battery.
    """
    return round(self.kWh*miles_per_kwh,2)

@patch(as_prop=True)
def cost_per_mile(self:Battery):
    """Returns the cost per mile for the battery.
    """
    return round(self.cost/self.range(miles_per_kwh=3),2)
